# battle-tested-solutions

Research mature, battle-tested solutions online that could replace custom implementations identified in the codebase.

1. **Review custom implementation candidates** - Use findings from `research/battle-tested-solutions.md` or identify custom code that needs alternatives
2. **Research mature alternatives online** - Find well-maintained, widely-adopted tools, libraries, or frameworks that address the same needs
3. **Evaluate fit and trade-offs** - Assess whether the battle-tested solution meets requirements and what migration would involve
4. **Assess maturity and support** - Research community size, maintenance activity, documentation quality, and long-term viability
5. **Prioritize recommendations** - Rank suggestions by impact (maintenance reduction, reliability improvement, community support)
6. **Provide migration guidance** - Outline clear paths for adopting recommended solutions where appropriate

Focus on:
- Official documentation and project pages
- GitHub/GitLab stars, activity, and community health
- Package manager listings and download statistics
- Comparison articles and benchmarks
- Migration guides and examples
- Community discussions and support channels

Consider both:
- Direct replacements (drop-in alternatives that require minimal refactoring)
- Architectural patterns (how established systems solve similar problems, even if not direct replacements)

Format findings as:
- Prioritized list of recommendations with source links
- Clear assessment of maturity, maintenance burden, and community support
- Migration complexity estimates
- Trade-off analysis (what you gain vs. what you might lose)
- Specific library/framework names with URLs and documentation links
- Code examples and migration patterns from online sources

Provide actionable recommendations with online source citations that help reduce maintenance burden and improve reliability through proven solutions.
